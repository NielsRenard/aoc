(load "~/code/aoc/load.ss")
(advent-year 19)
(advent-day 20)

(define world-map
  (list->vector
   (map (compose list->vector string->list)
	(with-input-from-file "large.in" lines-raw)
	;; (parse-advent lines-raw)
	)))

(define (world)
  (let ((t (make-eqv-hashtable))
	(h (vector-length world-map))
	(w (vector-length (vector-ref world-map 0))))
    (do ((i 0 (1+ i)))
	((= i h) t)
      (do ((j 0 (1+ j)))
	  ((= j w))
	(match (vector-ref (vector-ref world-map i) j)
	  (#\. (hashtable-set! t (make-rectangular j i) 'open))
	  (#\space (void)) (#\# (void))
	  (x (hashtable-set! t (make-rectangular j i) x)))))))

(define (letters world)
  (filter (lambda (z.x)
	    (not (eq? 'open (cdr z.x))))
	  (vector->list (hashtable-cells world))))

(define (english-order pair)
  (match pair
    (((u . x) (v . y))
     (let ((dz (- u v)))
       (if (real? dz)
	   (if (< (real-part u) (real-part v))
	       pair
	       (reverse pair))
	   (if (< (imag-part u) (imag-part v))
	       pair
	       (reverse pair)))))))

(define (inner-edges W)
  (define es '())
  (vector-for-each (lambda (pair)
		     (match pair
		       ((z . 'open)
			(for-each (lambda (w)
				    (when (eq? 'open (hashtable-ref W w #f))
				      (push! (list w z) es)))
				  (nesw z)))
		       (_ (void))))
		   (hashtable-cells W))
  es)

(define (world-graph W)
  (define ls (letters W))
  (define portals
    (sort (lambda (a b) (string<? (cdr a) (cdr b)))
	  (nub-equal
	   (filter-map (lambda (pair)
			 (let ((pair (english-order pair)))
			   (match pair
			     (((u . x) (v . y))
			      (let* ((dz (- u v))
				     (id (string x y)))
				(and (= 1 (magnitude dz))
				     (if (hashtable-ref W (+ u dz) #f)
					 (cons (+ u dz) id)
					 (cons (- v dz) id))))))))
		       (cartesian-product (list ls ls))))))
  (define n (length portals))
  (define G (inner-edges W))
  (match (map car portals)
    ((aa es ... zz)
     (let ((outer-edges (n-tuples 2 es)))
       (list portals aa zz G (append outer-edges (map reverse outer-edges)))))))

(define (outside? W)
  (define-values (xlo xhi ylo yhi)
    (bounding-box-C (apply append (inner-edges W))))
  (lambda (z)
    (or (memv (real-part z) (list xlo xhi))
	(memv (imag-part z) (list ylo yhi)))))

(define (solve cutoff)
  (define W (world))
  (define G1 (make-eqv-hashtable))
  (define G2 (make-eqv-hashtable))
  (define GR (make-eqv-hashtable))
  (define G (make-eqv-hashtable))
  (define VO (make-eqv-hashtable))
  (define VI (make-eqv-hashtable))
  (define out? (outside? W))
  (match (world-graph W)
    ((portals aa zz iedges oedges)
     (for-each (lambda (uv)
		 (match uv
		   ((x y)
		    (hashtable-update! G1 x (lambda (zs) (cons y zs)) '())
		    (hashtable-update! G1 y (lambda (zs) (cons x zs)) '()))))
	       (append iedges oedges))
     (for-each (lambda (uv)
		 (match uv
		   ((x y)
		    (hashtable-update! G2 x (lambda (zs) (cons y zs)) '())
		    (hashtable-update! G2 y (lambda (zs) (cons x zs)) '()))))
	       iedges)
     (for-each (lambda (uv)
		 (match uv
		   ((x y)
		    (hashtable-update! GR x (lambda (zs) (cons y zs)) '()))))
	       oedges)
     (let ((path
	    (bfs-path (cons 0 aa)
		      (cons 0 zz)
		      (lambda (d.z)
			(match d.z
			  ((d . z)
			   (if (< cutoff (abs d))
			       '()
			       (append (map (lambda (y)
					      (cons d y))
					    (hashtable-ref G2 z '()))
				       (filter (lambda (d.y)
						 (<= 0 (car d.y)))
					       (map (lambda (y)
						      (if (out? z)
							  (cons (1- d) y)
							  (cons (1+ d) y)))
						    (hashtable-ref GR z '())))))))))))
       (when path 
	 (map (lambda (d.z)
		(cond ((assoc (cdr d.z) portals) =>
		       (lambda (z.id)
			 (write (cons (car d.z) (cdr z.id))) (newline)))))
	      path))
       (values (and path (length path))
	       (bfs-distance aa zz (lambda (z) (hashtable-ref G1 z '()))))))))
